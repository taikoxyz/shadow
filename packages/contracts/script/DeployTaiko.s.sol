// SPDX-License-Identifier: MIT
pragma solidity ^0.8.33;

import {Script, console2} from "forge-std/Script.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import {Shadow} from "../src/impl/Shadow.sol";
import {DummyEtherMinter} from "../src/impl/DummyEtherMinter.sol";
import {ShadowVerifier} from "../src/impl/ShadowVerifier.sol";
import {Risc0CircuitVerifier} from "../src/impl/Risc0CircuitVerifier.sol";

contract DeployTaiko is Script {
    // Deployer: 0xe36C0F16d5fB473CC5181f5fb86b6Eb3299aD9cb
    address internal constant MAINNET_RISC0_VERIFIER_V3_0_1_SHANGHAI = 0xA5Da6507E6Ab8832EA3fDeB43bA6B7390952D8dA;

    address internal constant HOODI_RISC0_VERIFIER_V3_0_1_SHANGHAI = 0xd1934807041B168f383870A0d8F565aDe2DF9D7D;
    address internal constant HOODI_ANCHOR = 0x1670130000000000000000000000000000010001;

    // imageId in Digest::as_bytes() format (LE words, w0â†’w7)
    // Generated by: shadow-risc0-host circuit-id
    bytes32 internal constant HOODI_SHADOW_CLAIM_GUEST_ID = 0x37a5e85c934ec15f7752cfced2f407f40e6c28978dffcb3b895dc100a76acaf8;

    struct Deployment {
        address etherMinter;
        address risc0CircuitVerifier;
        address shadowVerifier;
        address shadowImplementation;
        address shadowProxy;
    }

    function run() external returns (Deployment memory deployed_) {
        uint256 deployerPrivateKey = vm.envUint("DEPLOYER_PK");
        address deployer = vm.addr(deployerPrivateKey);

        address owner = vm.envOr("OWNER", deployer);
        address anchor = vm.envOr("ANCHOR", HOODI_ANCHOR);
        address risc0Verifier = vm.envOr("RISC0_VERIFIER", HOODI_RISC0_VERIFIER_V3_0_1_SHANGHAI);
        bytes32 imageId = vm.envOr("IMAGE_ID", HOODI_SHADOW_CLAIM_GUEST_ID);

        vm.startBroadcast(deployerPrivateKey);

        deployed_.etherMinter = address(new DummyEtherMinter());

        deployed_.risc0CircuitVerifier = address(new Risc0CircuitVerifier(risc0Verifier, imageId));
        deployed_.shadowVerifier = address(new ShadowVerifier(anchor, deployed_.risc0CircuitVerifier));
        deployed_.shadowImplementation = address(new Shadow(deployed_.shadowVerifier, deployed_.etherMinter, owner));
        bytes memory initData = abi.encodeCall(Shadow.initialize, (owner));
        deployed_.shadowProxy = address(new ERC1967Proxy(deployed_.shadowImplementation, initData));

        vm.stopBroadcast();

        _logConfig(deployer, owner, anchor, risc0Verifier, imageId);
        _logDeployment(deployed_);
    }

    function _logConfig(
        address deployer,
        address owner,
        address anchor,
        address risc0Verifier,
        bytes32 imageId
    ) private view {
        console2.log("=== Deploy Config ===");
        console2.log("chainId", block.chainid);
        console2.log("deployer", deployer);
        console2.log("owner", owner);
        console2.log("feeRecipient", owner);
        console2.log("anchor", anchor);
        console2.log("risc0Verifier", risc0Verifier);
        console2.logBytes32(imageId);
        console2.log("=====================");
    }

    function _logDeployment(Deployment memory deployed_) private pure {
        console2.log("=== Deployed Contracts ===");
        console2.log("DummyEtherMinter", deployed_.etherMinter);
        console2.log("Risc0CircuitVerifier", deployed_.risc0CircuitVerifier);
        console2.log("ShadowVerifier", deployed_.shadowVerifier);
        console2.log("Shadow implementation", deployed_.shadowImplementation);
        console2.log("Shadow proxy", deployed_.shadowProxy);
        console2.log("==========================");
    }
}
