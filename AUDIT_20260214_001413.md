# Shadow Project Audit (2026-02-14 00:14:13 local)

Audit timestamp (file name): `20260214_001413`

Codebase:

- Path: `/Users/d/Projects/taiko/shadow-gpt`
- Git commit: `cc2722bee44188762811ab413f927895aff891c7` (worktree was dirty at audit time)

## Scope

In scope:

- Smart contracts (`packages/contracts`)
- RISC Zero prover pipeline (guest + host + core library) (`packages/risc0-prover`)
- CLI scripts (`packages/risc0-prover/scripts`)
- UI (`packages/ui`)
- Documentation (`PRD.md`, `PRIVACY.md`, and `packages/**/docs`)

Out of scope (assumed correct / treated as dependencies):

- Taiko protocol contracts, especially the system `ICheckpointStore`
- The deployed RISC Zero on-chain verifier contract implementation
- RPC providers and their availability/consistency
- Private key custody and user operational security (beyond documented guidance)

## Executive Summary

- Proving system in use: **RISC Zero zkVM** with **Groth16 receipts** for on-chain verification.
- No Circom/snarkjs/PLONK (BN128) proving code was found in the repo (only historical mention in a README).
- Recent breaking changes are consistently implemented across contracts/prover/UI/docs:
  - `noteIndex` and `powDigest` are **private witness** (enforced in the zkVM guest, not in public inputs or journal).
  - `stateRoot` is **derived on-chain** from `ICheckpointStore.getCheckpoint(blockNumber)` and is not claim calldata.
  - Claim fee added: **0.1%** (`amount / 1000`) minted to an immutable `feeRecipient` (set at implementation deployment time).
  - Nullifier uniqueness for identical notes is addressed by including `noteIndex` in nullifier derivation.
- Main audit risks:
  - The in-guest Ethereum MPT/RLP verifier is custom; edge-case correctness needs stronger test coverage (fuzzing + differential tests).
  - The protocol trust model depends on Taiko’s system checkpoint finality and correctness (explicitly trusted by design).

## System Overview (As Implemented)

High-level flow:

- User creates a deposit file (secret + note set).
- A deterministic `targetAddress` is derived from `(secret, chainId, notesHash)`.
- ETH is funded to `targetAddress` on **Ethereum Hoodi (L1, chainId `560048`)** as a normal transfer (effectively a burn to an unknown private key).
- Claimer generates a RISC0 proof that `targetAddress` had enough L1 balance at a checkpointed `stateRoot`.
- Claimer calls `Shadow.claim(proof, input)` on **Taiko Hoodi (L2, chainId `167013`)** to mint ETH to the `recipient` (minus fee), consuming a `nullifier`.

Key trust boundary:

- `stateRoot` is trusted to be correct/final because it comes from Taiko’s system `ICheckpointStore` (protocol-level guarantee).

### On-Chain Components

- `Shadow` (UUPS proxy):
  - Validates `chainId`, `amount`, `recipient`.
  - Calls `ShadowVerifier.verifyProof`.
  - Consumes nullifier (tracked internally in `Shadow` storage).
  - Applies fee and mints via `IEthMinter`.
- `ShadowVerifier`:
  - Reads checkpoint from `ICheckpointStore`.
  - Builds the circuit `publicInputs` array using derived `stateRoot`.
  - Delegates verification to `ICircuitVerifier`.
- `Risc0CircuitVerifier`:
  - ABI-decodes `proof` as `(bytes seal, bytes journal)`.
  - Checks journal fields match the expected values derived from `publicInputs`.
  - Calls the RISC0 verifier contract with `sha256(journal)` and `imageId`.

### Off-Chain Components

- `shadow-proof-core` (guest logic):
  - Validates note invariants and computes `targetAddress`, `nullifier`, and PoW.
  - Verifies an Ethereum account MPT proof against `stateRoot` to extract balance.
- RISC0 guest (`methods/guest`):
  - Reads `ClaimInput`, runs `evaluate_claim`, commits a packed journal.
- RISC0 host (`host`):
  - Generates receipts, verifies locally, exports seal+journal.
- CLI (`scripts/shadowcli.mjs`):
  - Orchestrates input generation and on-chain claim encoding.
- UI (`packages/ui`):
  - Generates deposit file v2 (mines PoW-valid secret client-side), guides prove/claim.

## Public Inputs vs Private Witness (Security + Privacy)

Publicly bound values (part of circuit public inputs and RISC0 journal binding):

- `blockNumber`
- `stateRoot` (public in the proof, but derived on-chain; not caller calldata)
- `chainId`
- `amount`
- `recipient`
- `nullifier`

Private witness values (not part of public inputs; not in the RISC0 journal):

- `secret`
- `noteIndex`
- Full note set (amount list + recipient hashes list, up to 5)
- MPT proof nodes (`eth_getProof` output)
- `powDigest = sha256(notesHash || secret)` (PoW validity is enforced in-guest)

Privacy consequence:

- Multiple claims from the same deposit are less trivially linkable via the proof journal because `powDigest` is not published.
- Claims remain publicly linkable by `recipient`, `amount`, and timing, and by the nullifier’s consumption history.

## Findings

### High Severity

None at time of latest edits in this file. (The earlier nonce-offset-based proxy prediction risk has been removed from `DeployTaiko.s.sol`, and nullifier tracking has been merged into `Shadow`.)

### Medium Severity

1. Custom in-guest Ethereum MPT/RLP verification needs deeper adversarial testing.
   - Location: `/Users/d/Projects/taiko/shadow-gpt/packages/risc0-prover/crates/shadow-proof-core/src/lib.rs`
   - What happens:
     - The guest verifies account proofs by parsing RLP, traversing trie nodes, and extracting the balance field.
   - Why it matters:
     - Any subtle bug could create:
       - false positives (minting based on an invalid proof), or
       - false negatives (valid claims fail).
     - This logic is security critical and complex.
   - Recommendation:
     - Add test vectors from real `eth_getProof` responses across multiple node shapes (branch/extension/leaf, hashed vs inlined children).
     - Add fuzz/property tests for RLP decoding and trie walking.
     - Add differential tests that compare extracted balance vs a reference implementation (off-chain, non-`no_std` test harness is fine).

2. Node version mismatch warning for UI builds (potential CI/product friction).
   - Location: UI build output warning (Vite requires Node `20.19+` or `22.12+`; local was `20.12.2`).
   - Why it matters:
     - Builds may fail in some environments once tooling tightens.
   - Recommendation:
     - Update `.nvmrc` / toolchain docs / CI to align to a supported Node version.

3. Protocol trust assumption is explicit and critical.
   - Location: `/Users/d/Projects/taiko/shadow-gpt/PRD.md`, `/Users/d/Projects/taiko/shadow-gpt/packages/contracts/src/impl/ShadowVerifier.sol`
   - What happens:
     - Correctness/finality of `stateRoot` is trusted via the Taiko system checkpoint store.
   - Why it matters:
     - If the checkpoint store were compromised (or misconfigured at deployment), proofs could be verified against a malicious state root.
   - Recommendation:
     - Treat `checkpointStore` address as a critical parameter; default to the canonical system address at deploy time and avoid “arbitrary address” deployments for production.
     - Add operational monitoring: alert on unexpected checkpoint store code hash/address changes.

### Low Severity / Informational

1. Fee rounding behavior is intentional and should be documented as such.
   - Location: `/Users/d/Projects/taiko/shadow-gpt/packages/contracts/src/impl/Shadow.sol`
   - Behavior:
     - `fee = amount / 1000` floors to zero for small amounts.
   - Recommendation:
     - Keep as-is if acceptable; otherwise define minimum fee or use rounding-up (has UX implications).

2. Claim event logs gross amount, not fee/net split.
   - Location: `/Users/d/Projects/taiko/shadow-gpt/packages/contracts/src/impl/Shadow.sol`
   - Recommendation:
     - Consider emitting `fee` and `netAmount` for easier indexing/accounting (not required for correctness).

3. Host tooling retains “legacy input” parsing path.
   - Location: `/Users/d/Projects/taiko/shadow-gpt/packages/risc0-prover/host/src/main.rs`
   - Note:
     - This is not Circom legacy; it is a compatibility path for older claim-input JSON encodings.
   - Recommendation:
     - If you want a strict post-migration toolchain, remove legacy parsing and bump input/proof file versions.

## Verification Of Key Cross-Language Bindings

Packed journal layout matches Solidity verifier offsets:

- Rust packed journal length: `116` bytes (`PACKED_JOURNAL_LEN`)
- Solidity expectation: `_JOURNAL_LEN = 116`
- Numeric fields are little-endian in both:
  - Rust uses `to_le_bytes()`
  - Solidity uses `_readLeUint` (little-endian)
- Byte fields (`stateRoot`, `recipient`, `nullifier`) are raw bytes and are compared in consistent order.

Public input array layout is deterministic and documented:

- Array length: `87`
- Offsets:
  - `blockNumber`: `0`
  - `stateRoot`: `1..32` (bytes)
  - `chainId`: `33`
  - `amount`: `34`
  - `recipient`: `35..54` (bytes)
  - `nullifier`: `55..86` (bytes)

Spec:

- `/Users/d/Projects/taiko/shadow-gpt/packages/contracts/docs/circuit-public-inputs-spec.md`

## Tests, Builds, Coverage (Executed During Audit)

Contracts:

- `pnpm test` (forge): **PASS**
  - 52 tests passed, 0 failed.
- `forge coverage --report summary`: **PASS**
  - Total: Lines `80.17%`, Statements `78.07%`, Branches `92.31%`, Funcs `84.44%`.

RISC0 prover:

- `cargo test -p shadow-proof-core`: **PASS**
- `cargo build --release -p shadow-risc0-host`: **PASS**

UI:

- `pnpm ui:build`: **PASS** (with Node version warning from Vite)

## Documentation Consistency Check

Docs reflect the current implementation:

- Proving system: RISC0 zkVM + Groth16 receipts (no Circom/snarkjs/PLONK).
- `noteIndex` and PoW are private witness values (not in journal).
- `stateRoot` is derived on-chain from the checkpoint store using `blockNumber` (not calldata).
- Claim fee: 0.1% (`amount / 1000`) to immutable `feeRecipient`.
- Circuit public input encoding and journal binding are specified in a canonical markdown spec.

Primary references:

- `/Users/d/Projects/taiko/shadow-gpt/PRD.md`
- `/Users/d/Projects/taiko/shadow-gpt/PRIVACY.md`
- `/Users/d/Projects/taiko/shadow-gpt/packages/contracts/docs/circuit-public-inputs-spec.md`

## Suggested Next Hardening Steps

1. Add fuzz + differential testing for the in-guest MPT/RLP verifier (security critical).
2. Pin/standardize toolchain versions (Node for UI; RISC0 toolchain versions for prover builds).
3. If moving toward production:
   - Replace `DummyEtherMinter` with the real Taiko system `IEthMinter`.
   - Add monitoring/alerting for critical config (checkpoint store address, verifier address, imageId).
